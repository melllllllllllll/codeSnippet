计算二进制中的1的个数 

传送门： Matrix67: The Aha Moments

比如 0x13， 表示成二进制是 00010011 一共有 3 个 1。这个操作在计算海明距离的时候十分有用，将两个操作数异或然后统计有多少个 1 就是海明距离。

很容易想到直接按位统计的算法：
int bits(uint32_t x) {
    int ans = 0;
    while (x) {
        ans += x & 1;
        x >>= 1;
    }
    return ans;
}

这个方案的时间和输入整形的最高位1有关，如果这个数正好是 2^31的话，那么耗费32个单位的时间。
能不能给力一点呢？
这里就要先介绍一个位运算操作，Lowbit，即计算一个整形中最低的那位1是什么。
int lowbit(int x) {
    return x & -x;
}

我们都知道，计算机中整数是用补码表示的，一个数的取负就是这个数按位取反再加一，举个例子
原值 00100100
取反 11011011
取负 11011100
原值 00100100
（原值写了两遍）可以发现一个数和它取负只有原值的最低位1都为1。这样 x & -x 就可以把原来的最低位取出来了。
这样，计算1的个数的代码可以改为
int bits(int x) {
    int ans = 0;
    while (x) {
        ans += x & 1;
        x -= x & -x;
    }
    return ans;
}

这个方案的复杂度和输入中1的个数有关，有几个1消耗几个单位的时间，还算不错。
能不能再给力一点呢？
可以
int bits(int x){
       x=(x & 0x55555555) + ((x >>1 ) & 0x55555555);
       x=(x & 0x33333333) + ((x >>2 ) & 0x33333333);
       x=(x & 0x0f0f0f0f) + ((x >>4 ) & 0x0f0f0f0f);
       x=(x & 0x00ff00ff) + ((x >>8 ) & 0x00ff00ff);
       x=(x & 0x0000ffff) + ((x >>16) & 0x0000ffff);
       return x;
}

这个代码一眼看上去就晕了是正常的，很多年前我看到也吓尿了。
其实这是优化是分治法和利用处理器字并行的结合。（也可以认为是一种SIMD（Single Instruction Multiple Data），就是一条指令处理多个数据）

先说这个方案如何分治的，我们用 0x35 举例，他的二进制是00110101

(这里应该有一张二叉树)

我们先把每2位二进制中的1算出来，然后每4位，然后每8位
（知乎代码块在手机和移动端浏览器缩进都不对，不要怪我）
1bit (00)(11)(01)(01)
2bit ( 0)( 2)( 1)( 1)
4bit (     2)(     2)
8bit (             4)
用这种方法，我们最终可以得到原数中一共有4个bit为1

再来说并行。首先给一句废话：2个bit里面最多有两个 bit 为 1，四个里面最多有 4 个bit为1，由此我们可以知道，一段01串里的1的个数再表示称整形，长度不会超过原串的长度。（比如 1111 有 4 个 1，把4表示成二进制是0100，不超过四位）

OK，我们有办法把在一次加法计算中把每两位的1都求出来吗？ YES
// (00)(11)(01)(01) => ( 0)( 2)( 1)( 1)
0x55 = 01010101 的意义相当于一个筛子，只允许奇数位的数字通过
         0x55: 01|01|01|01
            x: 00|11|01|01
     x & 0x55:  0| 1| 1| 1
       x >> 1: 00|01|10|10
(x>>1) & 0x55:  0| 1| 0| 0
            +: 00|10|01|01
                0| 2| 1| 1
看到这应该大概懂了，就是把偶数位的1向右对齐一下，再和奇数位的1求个和，这个过程中每两位是并行的。
然后计算每4位的和
// ( 0)( 2)( 1)( 1) => (     2)(     2)
              x: 0010|0101
           0x33: 0011|0011
       x & 0x33:   10|  01
         x >> 2: 0000|1001
(x >> 2) & 0x33:   00|  01
              +: 0010|0010
               :    2|   2   
后面的依此类推。

就这样，首先吧 32 个 1 位整形加成 16 个2 位整形，再加成 8 个4 位整形，4 个 8 位整形，2 个16位整形，1 个 32位整形，这么推下来就能统计出一个整形里面有多少个1啦。
而且，一个if都没有。
